I"®/<ul>
  <li>Awesome List: <a href="https://github.com/rdragos/awesome-mpc">Github: rdragos/awesome-mpc</a></li>
  <li>Book: <a href="https://securecomputation.org/">A Pragmatic Introcution to Secure Multi-Party Computation</a></li>
</ul>

<table>
  <thead>
    <tr>
      <th>Protocols</th>
      <th># Parties</th>
      <th># Rounds</th>
      <th># Circuit</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Yao</td>
      <td>2</td>
      <td>Constant</td>
      <td>Boolean</td>
    </tr>
    <tr>
      <td>GMW</td>
      <td>$\geq$ 3</td>
      <td>Circuit depth</td>
      <td>Boolean or arithmetic</td>
    </tr>
    <tr>
      <td>BGW</td>
      <td>$\geq$ 3</td>
      <td>Circuit depth</td>
      <td>Boolean or arithmetic</td>
    </tr>
    <tr>
      <td>BMR</td>
      <td>$\geq$ 3</td>
      <td>Constant</td>
      <td>Boolean</td>
    </tr>
    <tr>
      <td>GESS</td>
      <td>2</td>
      <td>Constant</td>
      <td>Boolean <em>formula</em></td>
    </tr>
  </tbody>
</table>

<h2 id="1-yaogarbled-circuit">1. Yao/Garbled Circuit</h2>

<blockquote>
  <p>A. C. Yao.  Protocols for secure computations.  In23rd FOCS, pages 160â€“164, 1982</p>
</blockquote>

<p>Yaoâ€™s protocol is usually seen as best-performing, and many state-of-art protocols build on Yapâ€™s GC. é‚£ä¹ˆé€šå¸¸æ¥è¯´ï¼Œä½¿ç”¨å§šå¼ç”µè·¯æ„å‘³ç€æ¯”è¾ƒä½çš„é€šä¿¡å¤æ‚åº¦ï¼ˆå›ºå®šè½®æ•°é€šä¿¡ï¼‰ã€‚</p>

<h3 id="protocolç®€åŒ–ç‰ˆæœ¬åè®®">Protocolï¼›ç®€åŒ–ç‰ˆæœ¬åè®®</h3>

<p><strong>Step 1: Assume we want to evaluate $\mathcal{F}(x,y)$, where party $P_1$ holds $x\in X$ and $P_2$ holds $y\in Y.$</strong></p>

<p>æˆ‘ä»¬é¦–å…ˆå°†å‡½æ•°$\mathcal{F}(x,y)$æƒ³è±¡æˆä¸€ä¸ªæŸ¥è¡¨ç®—æ³•ï¼ˆå¯¹äºè¾ƒå°çš„$X,Y$æ¥è¯´ï¼‰ã€‚é‚£ä¹ˆ $P_1$ å¯ä»¥ç”ŸæˆTable  $T_{x,y} = \langle \mathcal{F}(x,y)\rangle$ ã€‚$P_1$ will then encrypt $T$ by assigning a randomly-chosen strong key to <em>each</em> possible input $x$ and $y$. That is, for each $x\in X$ and each $y \in Y$, $P_1$ will randomly choose $k_x\in_R {0,1}^k$ and $k_y\in_R {0,1}^k$.</p>

<p><strong>Step 2: $P_1$ will send the encrypted (and permuted!) table $\langle Enc_{k_x, k_y}(T_{x,y})\rangle$ to $P_2$ and $k_x$.</strong></p>

<table>
  <tbody>
    <tr>
      <td>ç°åœ¨ $P_2$ å°±æ‹¥æœ‰äº† $\langle Enc_{k_x, k_y}(T_{x,y})\rangle$ã€$y$ã€$k_x$ï¼Œé‚£ä¹ˆä»…ä»…ç¼ºå°‘æ­£ç¡®çš„ $k_y$ å°±å¯ä»¥æ­£ç¡®è¿˜åŸå‡ºæŸ¥è¡¨çš„ç»“æœäº†ã€‚å½“ç„¶ï¼Œ $k_y$ çš„è·å–ä¸å¯ä»¥é€šè¿‡æ˜æ–‡ä¼ è¾“çš„å½¢å¼ï¼Œå› ä¸ºæ˜ å°„ $\mathcal{R}: y\to k_y$ æ˜¯ç”±$P_1$ ç”Ÿæˆï¼Œå› æ­¤åœ¨è·å–$k_x$ çš„è¿‡ç¨‹ä¸­ä½¿ç”¨äº† 1-out-of-</td>
      <td>Y</td>
      <td>OTåè®®ã€‚</td>
    </tr>
  </tbody>
</table>

<table>
  <tbody>
    <tr>
      <td>**Step 3: $P_2$ obtains $k_y$ using $\text{OT}^1_{</td>
      <td>Y</td>
      <td>}$**</td>
    </tr>
  </tbody>
</table>

<p>è·å–åˆ° $k_x, k_y$ å $P_2$ ä¼šé’ˆå¯¹ $T$ çš„æ¯ä¸€è¡Œè¿›è¡Œè§£å¯†ï¼Œåªæœ‰ä¸€è¡Œä¼šè§£å¯†æˆåŠŸå¹¶å¾—åˆ°è®¡ç®—ç»“æœã€‚</p>

<h3 id="protocolå®Œæ•´åè®®">Protocolï¼›å®Œæ•´åè®®</h3>

<p><strong>Step 1: Assume we want to evaluate $\mathcal{F}(x,y)$, where party $P_1$ holds $x\in X$ and $P_2$ holds $y\in Y.$</strong></p>

<p><strong>Step 2: $P_1$ will send the encrypted (and permuted!) table $\langle Enc_{k_x, k_y}(T_{x,y})\rangle$ to $P_2$ and $k_x$.</strong></p>

<p><strong>Step 3: $P_2$ obtains $k_y$ using $\text{OT}^1_{|Y|}$</strong></p>

<h3 id="optimaizationä¼˜åŒ–">Optimaizationï¼›ä¼˜åŒ–</h3>

<p><strong>1. $P_2$ å¦‚ä½•åˆ¤æ–­å“ªä¸€è¡Œæ˜¯æ­£ç¡®ç»“æœå‘¢ï¼Ÿï¼ˆå‡è®¾è§£å¯†å‡½æ•°ä¸ä¼šè¿”å›ERRORï¼‰</strong></p>

<p>æœ€ç®€å•çš„åŠæ³•æ˜¯è®© $P_1$ åœ¨ $T$ çš„æ˜æ–‡æœ«å°¾åŠ å…¥0ï¼Œè¿™æ ·çš„è¯å¯¹äº $P_2$ æ¥è¯´åªæœ‰è§£å¯†åç»“æœæœ«å°¾ä¸º0çš„æ‰æ˜¯æ­£ç¡®ç»“æœï¼ˆæ•ˆç‡æ¯”è¾ƒä½ä¸‹ï¼‰ã€‚</p>

<table>
  <tbody>
    <tr>
      <td><strong>ï¼ˆä¼˜åŒ–åçš„é«˜æ•ˆæ–¹æ³•ï¼‰Point-and-Permuteï¼š</strong> Interpret part of the key as a pointer to the permuted table $T$. It means on receivingg $k_x, k_y$, $P_2$ can efficiently use the first  $\lceil log</td>
      <td>X</td>
      <td>\rceil$ bits of $k_x$ and $\lceil log</td>
      <td>Y</td>
      <td>\rceil$ bits of $k_y$ to locate one row in $T$. Besides, key size must be maintained t o achieve the corresponding level of security.</td>
    </tr>
  </tbody>
</table>

<p><strong>2. å¦‚ä½•æœ‰æ•ˆå‡å°‘ $T$ çš„å¤§å°ï¼Ÿ</strong></p>

<p>Before optimazation size of $T$ scales linearly with the domain size of $\mathcal{F}$. Boolean circuit has domain size of 4, so we need to represent $\mathcal{F}$ as Boolean circuit $\mathcal{C}$.</p>

<p>Each cell of the look-up table encrypts the <em>label corresponding to the output computed by the gate.</em> é‚£ä¹ˆï¼Œå¯¹äºä¸€ä¸ªå¸ƒå°”ç”µè·¯çš„ $\mathcal{C}$ çš„ä¸€ä¸ª Gateï¼ˆinput wires: $w_i,w_j$, output wire: $w_t$ï¼‰æ¥è¯´:</p>

<p><script type="math/tex">T_{G}= \begin{bmatrix} \text{Enc}_{k_i^0,k_j^0}(k_t^{G(0,0)}) \\ \text{Enc}_{k_i^0,k_j^1}(k_t^{G(0,1)}) \\ \text{Enc}_{k_i^1,k_j^0}(k_t^{G(1,0)}) \\ \text{Enc}_{k_i^1,k_j^1}(k_t^{G(1,1)}) \end{bmatrix}</script> if G is AND, then <script type="math/tex">T_{G}= \begin{bmatrix} \text{Enc}_{k_i^0,k_j^0}(k_t^{0}) \\ \text{Enc}_{k_i^0,k_j^1}(k_t^{0}) \\ \text{Enc}_{k_i^1,k_j^0}(k_t^{0}) \\ \text{Enc}_{k_i^1,k_j^1}(k_t^{1}) \end{bmatrix}</script></p>

<p>åœ¨è¿™ç§æƒ…å†µä¸‹ï¼ˆBooleanï¼‰ï¼Œæˆ‘ä»¬åªéœ€è¦ 1bit çš„Point-and-Permuteå°±å¯ä»¥æˆåŠŸå®šä½äº†ã€‚</p>

<p><strong>3. æ¶æ„å®‰å…¨æ¨¡å‹ï¼Ÿ</strong></p>

<p>At an intuitive level, it is easy to see that this circuit-based construction is secure under semi-honest adversary.</p>

<p><strong>Security against malicious $P_1$ is easy</strong>, (we exclued OT, which has been fully studied) since it reveives no messages from $P_2$.</p>

<p><strong>Security against malicious $P_2$</strong>, security boils down to the observation that the <strong>evaluator $P_2$ never sees both labels for the same wire.</strong></p>

<p>To simulate $P_2$â€™s view, the simulator $Sim_{P_2}$ chooses random active labels for each wire, simulates the three â€œinactiveâ€ ciphertexts of each garbled gate as dummy cipher texts, and produces decoding information that decodes the active output wires to the functionâ€™s output.</p>

<h2 id="2-gmw-protocol">2. GMW Protocol</h2>

<blockquote>
  <p>O. Goldreich, S. Micali, and A. Wigderson.  How to play any mental game or A completenesstheorem for protocols with honest majority.  In19th STOC, pages 218â€“229, 1987.</p>
</blockquote>

<p>GMWé€‚ç”¨äºå¸ƒå°”ç”µè·¯å’Œè¿ç®—ç”µè·¯ã€‚ä½¿ç”¨æ­£å¸¸çš„Secret Sharingï¼Œå¹¶ä½¿ç”¨ Beaverâ€™s Multiplication Triples å»è§£å†³ä¹˜æ³•é—®é¢˜ä»¥åŠANDé—¨é—®é¢˜ï¼Œä¸‹é¢ä½¿ç”¨è¿ç®—ç”µè·¯è¿›è¡Œä¸¾ä¾‹ã€‚</p>

<ul>
  <li>Addition gates: $[x]+[y]$</li>
  <li>Multiplication gates: $[x]\cdot[y]$</li>
  <li>Multiplication-by-constant gates: $[x]\cdot c$</li>
</ul>

<h3 id="add-gate">ADD Gate</h3>

<p>For addition gate, consider input wires $\alpha, \beta$ and output wires $\gamma$. And consider the case we want to secure perform:</p>

<script type="math/tex; mode=display">f_\text{add}([\upsilon_\alpha],[\upsilon_\beta])=[\upsilon_\alpha+\upsilon_\beta]</script>

<p>Wire $\alpha$ shares its value with $x_{\alpha1}$ and $x_{\alpha2}$.
Wire $\beta$ shares its value to $x_{\beta1}$ and $x_{\beta2}$.</p>

<p>Wire $\alpha$ computes $(x_{\alpha1}+x_{\beta1})$</p>

<p>Wire $\beta$ computes $(x_{\alpha2}+x_{\beta2})$</p>

<h3 id="mul-gate">MUL Gate</h3>

<p>For multiplication gate, consider input wires $\alpha, \beta$ and output wires $\gamma$. And consider the case we want to secure perform:</p>

<script type="math/tex; mode=display">f_\text{mul}([\upsilon_\alpha],[\upsilon_\beta])=[\upsilon_\alpha\times\upsilon_\beta]</script>

<p>Wire $\alpha$ shares its value with $x_{\alpha1}$ and $x_{\alpha2}$.
Wire $\beta$ shares its value to $x_{\beta1}$ and $x_{\beta2}$.</p>

<p>ä¸ºäº†æˆåŠŸè®¡ç®—MULé—¨ï¼Œæˆ‘ä»¬éœ€è¦ä¸€ä¸ªsemi-honestå¹¶ä¸”ä¸ä¼šåˆè°‹æ”»å‡»çš„ç¬¬ä¸‰æ–¹ç”Ÿæˆå¹¶ç§˜å¯†å…±äº«$(a,b,c)$ï¼Œ å…¶ä¸­ $c=a\cdot b$</p>

<p>Wire $\alpha$ computes $(x_{\alpha1}+a_1)$, $(x_{\beta1}+b_1)$; Wire $\beta$ computes $(x_{\alpha2}+a_2)$, $(x_{\beta2}+b_2)$</p>

<p>æ‰§è¡Œä¸€æ¬¡ç§˜å¯†é‡æ„ï¼Œé‚£ä¹ˆåŒæ–¹å°±å‡æŒæœ‰ $(x_{\alpha}+a)$ å’Œ  $(x_{\beta}+b)$</p>

<p>Wire $\alpha$ computes $(x_{\alpha}+a)(x_{\beta}+b) + x_{\beta1}(x_{\alpha}+a) + x_{\alpha1}(x_{\beta}+a) + c_1$</p>

<p>Wire $\beta$ computes $x_{\beta2}(x_{\alpha}+a) + x_{\alpha2}(x_{\beta}+a) + c_2$</p>

<h2 id="3-bgw-protocol">3. BGW Protocol</h2>

<blockquote>
  <p>Completeness theorems for non-cryptographic fault-tolerant distributed computation, Ben-Or, Goldwasser, and Wigderson, 1988</p>
</blockquote>

<p>BGWåè®®æ˜¯æœ€å…ˆè¢«æå‡ºçš„å¤šæ–¹å®‰å…¨è®¡ç®—åè®®[1]ï¼Œä¸€äº›ç»†èŠ‚ä¿¡æ¯å¦‚ä¸‹æ‰€ç¤ºï¼š
The BGW protocol can be used to evaluate an <strong>arithmetic circuit over a field $\mathbb{F}$</strong>.</p>

<ul>
  <li>Addition gates: $[x]+[y]$</li>
  <li>Multiplication gates: $[x]\cdot[y]$</li>
  <li>Multiplication-by-constant gates: $[x]\cdot c$</li>
</ul>

<p>è¯¥åè®®ä½¿ç”¨ shamir ç§˜å¯†å…±äº«(Shamir, 1979)ï¼Œå¹¶åˆ©ç”¨äº†å…¶æŸäº›åŒæ€æ€§è´¨ã€‚ä¸‹åˆ—å…¬å¼ä¸º shamir ç§˜å¯†å…±äº«çš„æ–¹å¼ï¼Œå‡è®¾æˆ‘ä»¬æƒ³é’ˆå¯¹ç§˜å¯† $s$ è¿›è¡Œç§˜å¯†åˆ†äº«ï¼Œé‚£ä¹ˆæˆ‘ä»¬ä»¤ $a_0:=s$, $a_1\cdots a_t\leftarrow^r\mathbb{Z}_q$</p>

<script type="math/tex; mode=display">p(X)=a_0+a_1X+...+a_{t-1}X^{t-1}\text{ for all }a_i\in\mathbb{Z}_q</script>

<p>If we know $t$ points $(x_1,y_1), â€¦,(x_t,y_t)$, we can build the system on:</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{bmatrix}1 & x_0 & ... &x_0^{t-1} \\\vdots &\vdots & ... &\vdots \\1 & x_{t-1} &... & x_{t-1}^{t-1}\end{bmatrix}\begin{bmatrix}a_0 \\\vdots \\a_{t-1} \end{bmatrix}=\begin{bmatrix}y_0 \\\vdots \\y_{t-1} \end{bmatrix}\text{ mod }q %]]></script>

<p>If the determinant of $X$ is nonzero, we can solve $A=X^{-1}Y$ and find the coefficients of $p(X)$ using Lagrange interpolation.</p>

<h3 id="add-gate-1">ADD Gate</h3>

<p>For addition gate, consider input wires $\alpha, \beta$ and output wires $\gamma$. And consider the case we want to secure perform:</p>

<script type="math/tex; mode=display">f_\text{add}([\upsilon_\alpha],[\upsilon_\beta])=[\upsilon_\alpha+\upsilon_\beta]</script>

<p>we assume wire $\alpha$ shares its value with $(x_{\alpha1},p_{\alpha}(x_{\alpha1}))$ and $(x_{\alpha2},p_{\alpha}(x_{\alpha2}))$.
Wire $\beta$ shares its value to $(x_{\beta1},p_{\beta}(x_{\beta1}))$ and $(x_{\beta2},p_{\beta}(x_{\beta2}))$.</p>

<p>Then after sharing, wire $\alpha$ has
<script type="math/tex">(x_{\alpha1},p_{\alpha}(x_{\alpha1})), (x_{\beta1},p_{\beta}(x_{\beta1}))</script></p>

<p>And wire $\beta$ has
<script type="math/tex">(x_{\alpha2},p_{\alpha}(x_{\alpha2})), (x_{\beta2},p_{\beta}(x_{\beta2}))</script></p>

<p>How  about adding them together  as we did in GMW?
Defineing a new polynomial $p_{\gamma}(x)=p_{\alpha}(x)+p_{\beta}(x)$, then weâ€™ll find the above result is</p>

<script type="math/tex; mode=display">(x_{\alpha1}+x_{\beta1},p_{\gamma}(x_{\alpha1}+x_{\beta1}))</script>

<script type="math/tex; mode=display">(x_{\alpha2}+x_{\beta2},p_{\gamma}(x_{\alpha2}+x_{\beta2}))</script>

<p>which results in a valid polynimial $p_{\gamma}(x)$ and revealing $[\upsilon_\alpha+\upsilon_\beta]$</p>

<h3 id="mul-gate-1">MUL Gate</h3>

<p>For multiplication gate, consider input wires $\alpha, \beta$ and output wires $\gamma$. And consider the case we want to secure perform:</p>

<script type="math/tex; mode=display">f_\text{mul}([\upsilon_\alpha],[\upsilon_\beta])=[\upsilon_\alpha\times\upsilon_\beta]</script>

<h2 id="4-bmr-protocol">4. BMR Protocol</h2>

<blockquote>
  <p>D. Beaver,  S. Micali,  and P. Rogaway.  The round complexity of secure protocols.  In22ndSTOC, pages 503â€“513, 1990.</p>
</blockquote>

<p>å°† Yao ç”µè·¯ï¼ˆåŒæ–¹å®‰å…¨è®¡ç®—ï¼‰æ‰©å±•æˆä¸ºå¤šæ–¹å®‰å…¨è®¡ç®—ã€‚Perform a <strong>distributed</strong> GC generation, so that no single party knows the GC gneration secrets - the label assignment and correspondence.</p>

<p>GC generation is <em>independent</em> of the depth of the computed circuit $\mathcal{C}$. Therefore, $\mathcal{C}_{GEN}$ is constantly-depth for all compued circuits.</p>

<p>GC evaluation may be delivered to a designated player who will then evaluate it similarly to Yaoâ€™s GC.</p>

:ET